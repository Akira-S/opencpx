use Test::More;

plan skip_all => "resource intensive test, skipped unless ALL_TESTS environment variable is set"
       unless $ENV{ALL_TESTS};

plan tests => 4;

BEGIN { use_ok('VSAP::Server::Modules::vsap::config') };
use_ok('VSAP::Server::Test::Account');
use_ok('POSIX');

my $user1  = 'joefoo';
my $forked = 0;
our $Debug  = 0;
my $Pid    = $$;
my $Children = 3;
my $Child_Tests = 15;
my $Parent_Tests = 25;
my $is_linux=((POSIX::uname())[0] =~ /Linux/) ? 1 : 0;

my @users = map { "misternobody_$_" } (1 .. $Children);

## move existing file out of the way
rename("/usr/local/etc/cpx.conf", "/usr/local/etc/cpx.conf.$$")
  if -e "/usr/local/etc/cpx.conf";

## set up a user w/ mail, ftp
my $acctjoefoo = VSAP::Server::Test::Account->create( { username => 'joefoo', fullname => 'Joe Foo', password => 'joefoobar' });

for my $user ( @users ) {
	my $acctjoefoo2 = VSAP::Server::Test::Account->create( { username => $user, fullname => 'Joe Foo', password => 'joefoobar' });
}

## make us an SA
$acctjoefoo->make_sa("misternobody_1");

## create a config file
open CONFIG, ">/usr/local/etc/cpx.conf"
  or die "Could not write to cpx.conf: $!\n";
print CONFIG <<_CONFIG_;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE cpx_config SYSTEM "cpx_config.dtd">
<config>
  <meta>
    <version>1.06</version>
    <warning>Do not edit this file directly</warning>
    <rootbeer>Jones Soda Company</rootbeer>
    <pepper_sauce>Tabasco, McIlhenny Co., Avery Island, La.</pepper_sauce>
    <indian_proverb>Call on God, but row away from the rocks.</indian_proverb>
    <potshot>Micros~1: For when quality, reliability, and security just aren't that important!</potshot>
  </meta>
  <domains>
    <domain>
      <name>horace.com</name>
      <admin>horace</admin>
    </domain>
    <domain>
      <name>farley.com</name>
      <admin>farley</admin>
      <user_limit>0</user_limit>
      <alias_limit>5</alias_limit>
    </domain>
_CONFIG_

for my $user ( @users ) {
    print CONFIG <<_CONFIG_;
    <domain>
      <name>joefoo-$user.com</name>
      <admin>$user</admin>
    </domain>
_CONFIG_
}

print CONFIG <<_CONFIG_;
  </domains>
_CONFIG_

close CONFIG;

my $test_conf = new VSAP::Server::Modules::vsap::config( username => $user1 );
#print STDERR $test_conf->{dom}->toString(1);
undef $test_conf;

## try to recreate race conditions that wipe out the config file
my %CHILDREN = ();

use POSIX 'WNOHANG';
$SIG{CHLD} = sub {
    while( (my $child = waitpid(-1, WNOHANG)) > 0 ) {
	if( delete $CHILDREN{$child} ) {
	    debug("DELETING child pid: $child\n");
	}
    }
};

print STDERR "Forking children...\n" if $Debug;

## fork children
for my $user ( @users ) {
    my $pid = fork();
    die "Cannot fork: $!\n" unless defined $pid;
    $forked = 1;

    ## child
    unless( $pid ) {
	$ENV{'VST_NO_CLEANUP'} = 1; 
	debug("Child process now working");
	undef $Pid;  ## mark us as a child

	for( my $i = 0; $i < $Child_Tests; $i++ ) {
	    my $conf2 = new VSAP::Server::Modules::vsap::config( username => $user );
	    select undef, undef, undef, rand(0.01);

	    if( $i == 0 || $i == 1 ) {
		$conf2->domain("blackpeasoup.tld");
		pwint(1, '');  ## sets text left during harness
		pwint(1, "\U$user\E: " . $conf2->domain);
	    }

	    elsif( $i % 2 ) {
                local $SIG{CHLD} = 'IGNORE';
		$conf2->services( fileman => 1, webmail => 0, mail => 0 );
		pwint(1, "\U$user\E: setting services");
	    }

	    elsif( $i % 3 ) {
                local $SIG{CHLD} = 'IGNORE';
		$conf2->services( fileman => 0, webmail => 1, mail => 1 );
		pwint(1, "\U$user\E: setting services");
	    }

	    elsif( $i % 5 ) {
		$conf2->services( ftp => 0, mail => 0 );
		pwint(1, "\U$user\E: setting services");
	    }

	    elsif( $i % 7 ) {
		$conf2->services( ftp => 1, mail => 1 );
		pwint(1, "\U$user\E: setting services");
	    }

	    else {
		$conf2->fullname("Barney Hare");
                $conf2->users();
		pwint(1, "\U$user\E: setting fullname");
	    }
	}

	debug("CHILD about to exit");
	exit;
    }

    ## parent in loop
    debug("Parent process now working (created child $pid).");
    $CHILDREN{$pid} = 1;
}


## parent's loop
for( my $i = 0; $i < $Parent_Tests; $i++ ) {
    my $conf1 = new VSAP::Server::Modules::vsap::config( username => $user1 );
    select undef, undef, undef, rand(0.01);

    ## do some random things
    if( $i == 1 ) {
	pwint(0, "USER1: Setting domain now");
	$conf1->domain("wormsaregoodfood.tld");
    }
    if( $i % 2 ) {
	pwint(0, "USER1: Setting webmail");
	my @users = $conf1->services(webmail => 1);
    }
    elsif( $i % 3 ) {
        local $SIG{CHLD} = 'IGNORE';
	pwint(0, "USER1: Setting services");
	$conf1->services( webmail => 0, mail => 0 );
    }
    elsif( $i % 5 ) {
        local $SIG{CHLD} = 'IGNORE';
	pwint(0, "USER1: Setting services");
	$conf1->services( webmail => 1, mail => 1 );
    }
    elsif( $i % 7 ) {
	pwint(0, "USER1: Refresh");
	$conf1->refresh;
    }
    elsif( $i % 11 ) {
	pwint(0, "USER1: Changing fullname");
	my %bah = $conf1->fullname("Horsey Sauce");
    }
    elsif( $i % 13 ) {
	pwint(0, "USER1: Changing fullname");
	$conf1->fullname("Horsey Sauce Rocks");
    }
    else {
	pwint(0, "USER1: Unsetting webmail");
	$conf1->services( webmail => 0 );
    }
}

## wait until the child is done mucking about
while( keys %CHILDREN ) {
    debug("Still have children: " . scalar(keys %CHILDREN));
    my $children = join(',', keys %CHILDREN);
    debug("Parent in END block. Waiting for children ($children)...");
    select undef, undef, undef, 0.5;
}
debug("PARENT about to exit");

my $conf = new VSAP::Server::Modules::vsap::config( username => $user1 );
pwint(0, " " x 60);
is( $conf->domain, "wormsaregoodfood.tld", "domain is achieving super shuttle diplomacy" );

END {
    if( $forked ) {
	unless( $Pid ) {
	    debug("Child in END block. Skipping");
	    return;
	}
    }

    getpwnam($user1)    && system qq(vrmuser -y $user1 2>/dev/null);

    for my $user ( @users ) {
	getpwnam($user) && system qq(vrmuser -y $user 2>/dev/null);
    }

    ## move old file back
    rename("/usr/local/etc/cpx.conf.$$", "/usr/local/etc/cpx.conf")
      if -e "/usr/local/etc/cpx.conf.$$";
}

sub debug {
    return unless $Debug;
    my $msg = shift;
    $msg =~ s/\n$//g;
    print STDERR $msg . "\n";
}

sub pwint {
    my $pos = shift;
    my $msg = shift;
    my $nl  = ($Debug ?  "\n" : "\r");
    print STDERR ($pos ? " " x 25 . $msg : $msg . " " x 50) . $nl;
}
